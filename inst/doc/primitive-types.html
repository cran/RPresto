<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Primitive Presto data types to R types</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Primitive Presto data types to R types</h1>



<p>In this vignette, we introduce how primitive Presto data types are
translated into R types in the <code>RPresto</code> package.</p>
<div id="package-setup" class="section level2">
<h2>Package setup</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(RPresto)</span></code></pre></div>
<p>You can check your <code>RPresto</code> version by running the
<code>packageVersion()</code> function. <strong>You need version 1.3.9
or later to have a more comprehensive and robust primitive types
support.</strong></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="fu">packageVersion</span>(<span class="st">&quot;RPresto&quot;</span>)</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="co">#&gt; [1] &#39;1.4.7&#39;</span></span></code></pre></div>
</div>
<div id="overview" class="section level2">
<h2>Overview</h2>
<p>Here <em>primitive types</em> refer to basic data types that are
atomic and non-nested (as opposed to structural types such as
<code>ARRAY</code>, <code>MAP</code>, and <code>ROW</code>). Refer to
the <a href="https://prestodb.io/docs/current/language/types.html">Presto
documentation</a> for a complete list of Presto data types.</p>
<p>We don’t currently support all of Presto’s primitive types. Here we
summarize what’s supported and what those supported types map to in
R.</p>
<table>
<thead>
<tr class="header">
<th>Category</th>
<th>Presto data type</th>
<th>R type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Boolean</td>
<td>BOOLEAN</td>
<td>logical</td>
</tr>
<tr class="even">
<td>Integer</td>
<td>TINYINT</td>
<td>integer</td>
</tr>
<tr class="odd">
<td>Integer</td>
<td>SMALLINT</td>
<td>integer</td>
</tr>
<tr class="even">
<td>Integer</td>
<td>INTEGER</td>
<td>integer</td>
</tr>
<tr class="odd">
<td>Integer</td>
<td>BIGINT</td>
<td>{<strong>integer</strong>|integer64|numeric|character}</td>
</tr>
<tr class="even">
<td>Floating-point</td>
<td>REAL</td>
<td>numeric</td>
</tr>
<tr class="odd">
<td>Floating-point</td>
<td>DOUBLE</td>
<td>numeric</td>
</tr>
<tr class="even">
<td>Fixed-precision</td>
<td>DECIMAL</td>
<td>character</td>
</tr>
<tr class="odd">
<td>String</td>
<td>VARCHAR</td>
<td>character</td>
</tr>
<tr class="even">
<td>String</td>
<td>CHAR</td>
<td>character</td>
</tr>
<tr class="odd">
<td>String</td>
<td>VARBINARY</td>
<td>raw</td>
</tr>
<tr class="even">
<td>String</td>
<td>JSON</td>
<td><strong>not supported</strong></td>
</tr>
<tr class="odd">
<td>Date and Time</td>
<td>DATE</td>
<td>Date (S3 class)</td>
</tr>
<tr class="even">
<td>Date and Time</td>
<td>TIME</td>
<td>difftime (S3 class)</td>
</tr>
<tr class="odd">
<td>Date and Time</td>
<td>TIME WITH TIME ZONE</td>
<td>difftime (S3 class)</td>
</tr>
<tr class="even">
<td>Date and Time</td>
<td>TIMESTAMP</td>
<td>POSIXct (S3 class)</td>
</tr>
<tr class="odd">
<td>Date and Time</td>
<td>TIMESTAMP WITH TIME ZONE</td>
<td>POSIXct (S3 class)</td>
</tr>
<tr class="even">
<td>Date and Time</td>
<td>INTERVAL YEAR TO MONTH</td>
<td>Duration (S4 class)</td>
</tr>
<tr class="odd">
<td>Date and Time</td>
<td>INTERVAL DAY TO SECOND</td>
<td>Duration (S4 class)</td>
</tr>
</tbody>
</table>
</div>
<div id="walkthrough-preparation" class="section level2">
<h2>Walkthrough preparation</h2>
<div id="local-presto-server-in-memory" class="section level3">
<h3>Local Presto server in memory</h3>
<p>We assume that the user already have a Presto server with a memory
connector set up. If you don’t have such a server set up, refer to the
<a href="https://prestodb.io/docs/current/connector/memory.html">Presto
documentation</a> for instructions if you want to follow along.</p>
</div>
<div id="presto-connection-in-r" class="section level3">
<h3>Presto connection in R</h3>
<p>We first create a <code>PrestoConnection</code> which will serve as
the bridge between the Presto server and R.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>con <span class="ot">&lt;-</span> DBI<span class="sc">::</span><span class="fu">dbConnect</span>(</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>  <span class="at">drv =</span> RPresto<span class="sc">::</span><span class="fu">Presto</span>(),</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>  <span class="at">host =</span> <span class="st">&quot;http://localhost&quot;</span>,</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>  <span class="at">port =</span> <span class="dv">8080</span>,</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>  <span class="at">user =</span> <span class="fu">Sys.getenv</span>(<span class="st">&quot;USER&quot;</span>),</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>  <span class="at">catalog =</span> <span class="st">&quot;memory&quot;</span>,</span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>  <span class="at">schema =</span> <span class="st">&quot;default&quot;</span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>)</span></code></pre></div>
<p>We first issue a simple query to see if the Presto connection is
working properly.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>DBI<span class="sc">::</span><span class="fu">dbGetQuery</span>(con, <span class="st">&quot;SELECT 1+1 AS res&quot;</span>)</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a><span class="co">#&gt; # A tibble: 1 × 1</span></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="co">#&gt;     res</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a><span class="co">#&gt;   &lt;int&gt;</span></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a><span class="co">#&gt; 1     2</span></span></code></pre></div>
</div>
<div id="primitive-data-types-table-in-presto" class="section level3">
<h3>Primitive data types table in Presto</h3>
<p>To illustrate how those primitive types are mapped to R types in
bulk, we first create a made-up table with 3 rows and 17 fields (i.e.,
one column for each supported Presto type).</p>
<p>We create the table using an auxiliary
<code>create_primitive_types_table()</code> function included in the
package.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>RPresto<span class="sc">:::</span><span class="fu">create_primitive_types_table</span>(</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>  con, <span class="at">table_name =</span> <span class="st">&quot;presto_primitive_types&quot;</span>, <span class="at">verbose =</span> <span class="cn">FALSE</span></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>)</span></code></pre></div>
<p>We can check if the table now exists in Presto.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>DBI<span class="sc">::</span><span class="fu">dbExistsTable</span>(con, <span class="st">&quot;presto_primitive_types&quot;</span>)</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>We can list the fields in the table. They are named after the Presto
types they represent.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>DBI<span class="sc">::</span><span class="fu">dbListFields</span>(con, <span class="st">&quot;presto_primitive_types&quot;</span>)</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="co">#&gt;  [1] &quot;boolean&quot;                &quot;tinyint&quot;                &quot;smallint&quot;              </span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a><span class="co">#&gt;  [4] &quot;integer&quot;                &quot;bigint&quot;                 &quot;real&quot;                  </span></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="co">#&gt;  [7] &quot;double&quot;                 &quot;decimal&quot;                &quot;varchar&quot;               </span></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a><span class="co">#&gt; [10] &quot;char&quot;                   &quot;varbinary&quot;              &quot;date&quot;                  </span></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a><span class="co">#&gt; [13] &quot;time&quot;                   &quot;time_with_tz&quot;           &quot;timestamp&quot;             </span></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a><span class="co">#&gt; [16] &quot;timestamp_with_tz&quot;      &quot;interval_year_to_month&quot; &quot;interval_day_to_second&quot;</span></span></code></pre></div>
</div>
</div>
<div id="data-types-mapping-to-r" class="section level2">
<h2>Data types mapping to R</h2>
<div id="boolean" class="section level3">
<h3>Boolean</h3>
<p>Translating boolean values from Presto to R is fairly
straightforward. <code>true</code> and <code>false</code> values are
mapped to <code>TRUE</code> and <code>FALSE</code> in R and
<code>null</code> is mapped to <code>NA</code> which is by default a
<code>logical</code> (i.e., boolean) type in R.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>(</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>  df.boolean <span class="ot">&lt;-</span> <span class="fu">dbGetQuery</span>(con, <span class="st">&quot;SELECT boolean FROM presto_primitive_types&quot;</span>)</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>)</span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a><span class="co">#&gt; # A tibble: 3 × 1</span></span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a><span class="co">#&gt;   boolean</span></span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a><span class="co">#&gt;   &lt;lgl&gt;  </span></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a><span class="co">#&gt; 1 TRUE   </span></span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a><span class="co">#&gt; 2 FALSE  </span></span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a><span class="co">#&gt; 3 NA</span></span></code></pre></div>
<p>We can verify that all three values in R are
<code>logical</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>purrr<span class="sc">::</span><span class="fu">map_chr</span>(df.boolean<span class="sc">$</span>boolean, class)</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="co">#&gt; [1] &quot;logical&quot; &quot;logical&quot; &quot;logical&quot;</span></span></code></pre></div>
</div>
<div id="integers" class="section level3">
<h3>Integers</h3>
<p>Presto has 4 integer data types.</p>
<ul>
<li><p><a href="https://prestodb.io/docs/current/language/types.html#tinyint"><code>TINYINT</code></a>
is 8-bit and ranges from <code>-2^7</code> to
<code>2^7-1</code>.</p></li>
<li><p><a href="https://prestodb.io/docs/current/language/types.html#smallint"><code>SMALLINT</code></a>
is 16-bit and ranges from <code>-2^15</code> to
<code>2^15-1</code>.</p></li>
<li><p><a href="https://prestodb.io/docs/current/language/types.html#integer"><code>INTEGER</code></a>
is 32-bit and ranges from <code>-2^31</code> to
<code>2^31-1</code>.</p></li>
<li><p><a href="https://prestodb.io/docs/current/language/types.html#bigint"><code>BIGINT</code></a>
is 64-bit and ranges from <code>-2^63</code> to
<code>2^63-1</code>.</p></li>
</ul>
<table>
<thead>
<tr class="header">
<th>Presto data type</th>
<th align="center">Bits</th>
<th align="center">Minimum value</th>
<th align="center">Maximum value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>TINYINT</td>
<td align="center">8</td>
<td align="center">-128</td>
<td align="center">127</td>
</tr>
<tr class="even">
<td>SMALLINT</td>
<td align="center">16</td>
<td align="center">-32,768</td>
<td align="center">32,767</td>
</tr>
<tr class="odd">
<td>INTEGER</td>
<td align="center">32</td>
<td align="center">-2,147,483,648</td>
<td align="center">2,147,483,647</td>
</tr>
<tr class="even">
<td>BIGINT</td>
<td align="center">64</td>
<td align="center">-9,223,372,036,854,775,808</td>
<td align="center">9,223,372,036,854,775,807</td>
</tr>
</tbody>
</table>
<p>In comparison, base R only ships with one 32-bit integer type, but
the range is slightly different from Presto. R’s integer type ranges
from <code>-2^31+1 = -2,147,483,647</code> to
<code>2^31-1 = 2,147,483,647</code>. The one number (out of ~4.3 billion
32-bit integer numbers) that’s a valid <code>INTEGER</code> in Presto
but not in R is the range lower bound <code>-2,147,483,648</code>.</p>
<div id="non-bigint-integers" class="section level4">
<h4>Non-BIGINT integers</h4>
<p>Since all <code>TINYINT</code>, <code>SMALLINT</code>, and
<code>INTEGER</code> numbers (except <code>-2,147,483,648</code>) can be
fit into R’s <code>integer</code> type, we translate all of them to
<code>integer</code>s.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>(</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>  df.non_bigint_int <span class="ot">&lt;-</span> <span class="fu">dbGetQuery</span>(</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>    con, <span class="st">&quot;SELECT tinyint, smallint, integer FROM presto_primitive_types&quot;</span></span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>  )</span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>)</span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a><span class="co">#&gt; # A tibble: 3 × 3</span></span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a><span class="co">#&gt;   tinyint smallint     integer</span></span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a><span class="co">#&gt;     &lt;int&gt;    &lt;int&gt;       &lt;int&gt;</span></span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a><span class="co">#&gt; 1    -128   -32768 -2147483647</span></span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a><span class="co">#&gt; 2     127    32767  2147483647</span></span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a><span class="co">#&gt; 3      NA       NA          NA</span></span></code></pre></div>
<p>We can verify that all three columns in R are <code>integer</code>
types.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>purrr<span class="sc">::</span><span class="fu">map_chr</span>(df.non_bigint_int, class)</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a><span class="co">#&gt;   tinyint  smallint   integer </span></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a><span class="co">#&gt; &quot;integer&quot; &quot;integer&quot; &quot;integer&quot;</span></span></code></pre></div>
<p>We can also show that mapping the one exception
<code>-2,147,483,648</code> to R results in an error while the query
runs correctly in Presto. <strong>Users whose data contains the
exceptional integer should consider using the <code>BIGINT</code> type
rather than <code>INTEGER</code> to encode the data in
Presto.</strong></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="fu">dbGetQuery</span>(con, <span class="st">&quot;SELECT CAST(&#39;-2147483648&#39; AS INTEGER) AS non_bigint_exception&quot;</span>)</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a><span class="co">#&gt; # A tibble: 1 × 1</span></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a><span class="co">#&gt;   non_bigint_exception</span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a><span class="co">#&gt;                  &lt;int&gt;</span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a><span class="co">#&gt; 1                   NA</span></span></code></pre></div>
</div>
<div id="bigint-integers" class="section level4">
<h4>BIGINT integers</h4>
<p>Since the Presto <code>BIGINT</code> type is 64-bit, its range is
clearly much wider than base R’s <code>integer</code> type.</p>
<p>However, by default we still map <code>BIGINT</code> integers from
Presto to <code>integer</code> in R, for two reasons.</p>
<ol style="list-style-type: decimal">
<li><p>R doesn’t have native 64-bit integer support yet. Mapping
<code>BIGINT</code> to a 64-bit integer in R will require additional
package and add extra dependencies.</p></li>
<li><p>The 32-bit integer range covers 2+ billion positive integers and
4.3 billion integers in total. Most integer values used in data analysis
and modeling can be well covered in that range.</p></li>
</ol>
<p>Besides the default mapping to <code>integer</code> (albeit 32-bit)
type, we offer three other options when it comes <code>BIGINT</code>
mapping.</p>
<ol style="list-style-type: decimal">
<li><p>Firstly, using the <code>bigint = &quot;character&quot;</code> argument
instructs <code>RPresto</code> to cast the <code>BIGINT</code> value to
a <code>character</code> type. This is particularly useful when
<code>BIGINT</code> is used to store long IDs rather than large numbers
(i.e., the numbers are not used in arithmetic computations).</p></li>
<li><p>Using <code>bigint = &quot;integer64&quot;</code> makes
<code>RPresto</code> translate <code>BIGINT</code> values to a value of
the <code>integer64</code> S3 class from the <code>bit64</code>
package.</p></li>
<li><p><code>bigint = &quot;numeric&quot;</code> makes <code>RPresto</code> store
the <code>BIGINT</code> value in a <code>numeric</code> ( i.e.,
<code>double</code>) type.</p></li>
</ol>
<p>Whenever we map an integer to another numeric type, we always need to
consider the precision of the mapping, that is, whether there’s any
precision loss during the translation. Among the three translation
options above, the first one (i.e., casting <code>BIGINT</code> to
<code>character</code>) doesn’t involve any precision translation, so we
will focus the precision discussion on the other two translations (
<code>bit64::integer64</code> and <code>numeric</code>).</p>
<p>On the receiving end, the <code>bit64::integer64</code> type has a
range from <code>-2^63+1 = -9,223,372,036,854,775,807</code> to
<code>2^63-1 = 9,223,372,036,854,775,807</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>bit64<span class="sc">::</span><span class="fu">lim.integer64</span>()</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a><span class="co">#&gt; integer64</span></span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a><span class="co">#&gt; [1] -9223372036854775807 9223372036854775807</span></span></code></pre></div>
<p>Comparing the range to Presto’s <code>BIGINT</code> range, it seems
that in theory the <code>bit64::integer64</code> range is only
infinitesimally smaller than the <code>BIGINT</code> range by 1 number
(again, the lower bound number). However, in practice, the range of
<code>BIGINT</code> values that can be translated into
<code>bit64::integer64</code> <strong>without precision loss</strong> is
much smaller.</p>
<p>The limitation comes from how the <a href="https://prestodb.io/docs/current/develop/client-protocol.html">Presto
REST API</a> communicates data with R. It uses the JSON format to encode
the query result data and sends it to R for <code>RPresto</code> to
process.</p>
<p>JSON by default encodes integers as <code>double</code> numbers, so
its <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER">precision
is limited</a> to <code>+/-(2^53-1) = +/-9,007,199,254,740,991</code>.
Any integers outside of this range will lose precision during the
translation.</p>
<p>Since the translation limitation is caused by the JSON format
encoding integers using <code>double</code>, the same limitation applies
when <code>BIGINT</code> values are mapped to <code>numeric</code> types
in R.</p>
<table>
<colgroup>
<col width="11%" />
<col width="9%" />
<col width="35%" />
<col width="42%" />
</colgroup>
<thead>
<tr class="header">
<th>bigint =</th>
<th>R type</th>
<th>Range without precision loss</th>
<th>Range with possible precision loss</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>character</td>
<td>character</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="even">
<td>integer64</td>
<td>bit64::integer64</td>
<td>+/-9,007,199,254,740,991</td>
<td>+/- 9,223,372,036,854,775,807</td>
</tr>
<tr class="odd">
<td>numeric</td>
<td>numeric</td>
<td>+/-9,007,199,254,740,991</td>
<td>[-9,223,372,036,854,775,808, 9,223,372,036,854,775,807]</td>
</tr>
</tbody>
</table>
<p>The table created by the <code>create_primitive_types_table()</code>
function has the values from the no-precision-lost range. Below we show
how different <code>bigint</code> arguments change the output R
types.</p>
<ul>
<li><code>bigint = &quot;character&quot;</code></li>
</ul>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="fu">dbGetQuery</span>(</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>  con, <span class="st">&quot;SELECT bigint FROM presto_primitive_types&quot;</span>, <span class="at">bigint =</span> <span class="st">&quot;character&quot;</span></span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a>)</span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a><span class="co">#&gt; # A tibble: 3 × 1</span></span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a><span class="co">#&gt;   bigint           </span></span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a><span class="co">#&gt;   &lt;chr&gt;            </span></span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a><span class="co">#&gt; 1 -9007199254740991</span></span>
<span id="cb14-8"><a href="#cb14-8" tabindex="-1"></a><span class="co">#&gt; 2 9007199254740991 </span></span>
<span id="cb14-9"><a href="#cb14-9" tabindex="-1"></a><span class="co">#&gt; 3 &lt;NA&gt;</span></span></code></pre></div>
<ul>
<li><code>bigint = &quot;integer64&quot;</code></li>
</ul>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="fu">dbGetQuery</span>(</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>  con, <span class="st">&quot;SELECT bigint FROM presto_primitive_types&quot;</span>, <span class="at">bigint =</span> <span class="st">&quot;integer64&quot;</span></span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>)</span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a><span class="co">#&gt; # A tibble: 3 × 1</span></span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a><span class="co">#&gt;              bigint</span></span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a><span class="co">#&gt;             &lt;int64&gt;</span></span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a><span class="co">#&gt; 1 -9007199254740991</span></span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a><span class="co">#&gt; 2  9007199254740991</span></span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a><span class="co">#&gt; 3                NA</span></span></code></pre></div>
<ul>
<li><code>bigint = &quot;numeric&quot;</code></li>
</ul>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="fu">dbGetQuery</span>(</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>  con, <span class="st">&quot;SELECT bigint FROM presto_primitive_types&quot;</span>, <span class="at">bigint =</span> <span class="st">&quot;numeric&quot;</span></span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>)</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a><span class="co">#&gt; # A tibble: 3 × 1</span></span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a><span class="co">#&gt;              bigint</span></span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a><span class="co">#&gt;               &lt;dbl&gt;</span></span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a><span class="co">#&gt; 1 -9007199254740991</span></span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a><span class="co">#&gt; 2  9007199254740991</span></span>
<span id="cb16-9"><a href="#cb16-9" tabindex="-1"></a><span class="co">#&gt; 3                NA</span></span></code></pre></div>
<p>If you attempt to translate integers outside of the no-precision-loss
range, a warning message will show up.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="fu">dbGetQuery</span>(</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>  con,</span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a>  <span class="st">&quot;</span></span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a><span class="st">  SELECT SIGN(bigint) * (ABS(bigint) + 1) AS bigint_precision_loss</span></span>
<span id="cb17-5"><a href="#cb17-5" tabindex="-1"></a><span class="st">  FROM presto_primitive_types</span></span>
<span id="cb17-6"><a href="#cb17-6" tabindex="-1"></a><span class="st">  &quot;</span>,</span>
<span id="cb17-7"><a href="#cb17-7" tabindex="-1"></a>  <span class="at">bigint =</span> <span class="st">&quot;numeric&quot;</span></span>
<span id="cb17-8"><a href="#cb17-8" tabindex="-1"></a>)</span>
<span id="cb17-9"><a href="#cb17-9" tabindex="-1"></a><span class="co">#&gt; Warning in as.double.integer64(x): integer precision lost while converting to</span></span>
<span id="cb17-10"><a href="#cb17-10" tabindex="-1"></a><span class="co">#&gt; double</span></span>
<span id="cb17-11"><a href="#cb17-11" tabindex="-1"></a><span class="co">#&gt; # A tibble: 3 × 1</span></span>
<span id="cb17-12"><a href="#cb17-12" tabindex="-1"></a><span class="co">#&gt;   bigint_precision_loss</span></span>
<span id="cb17-13"><a href="#cb17-13" tabindex="-1"></a><span class="co">#&gt;                   &lt;dbl&gt;</span></span>
<span id="cb17-14"><a href="#cb17-14" tabindex="-1"></a><span class="co">#&gt; 1     -9007199254740992</span></span>
<span id="cb17-15"><a href="#cb17-15" tabindex="-1"></a><span class="co">#&gt; 2      9007199254740992</span></span>
<span id="cb17-16"><a href="#cb17-16" tabindex="-1"></a><span class="co">#&gt; 3                    NA</span></span></code></pre></div>
</div>
</div>
<div id="floating-numbers" class="section level3">
<h3>Floating numbers</h3>
<p>R only has one floating point data type, <code>double</code> (its
class is <code>numeric</code>). All floating numbers are stored in
double precision format (i.e., 64-bit). This matches Presto’s <a href="https://prestodb.io/docs/current/language/types.html#double"><code>DOUBLE</code></a>
type, so translation between Presto and R is straightforward.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>(</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>  df.floating_point <span class="ot">&lt;-</span> <span class="fu">dbGetQuery</span>(</span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a>    con,</span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a>    <span class="st">&quot;SELECT real, double FROM presto_primitive_types&quot;</span></span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a>  )</span>
<span id="cb18-6"><a href="#cb18-6" tabindex="-1"></a>)</span>
<span id="cb18-7"><a href="#cb18-7" tabindex="-1"></a><span class="co">#&gt; # A tibble: 3 × 2</span></span>
<span id="cb18-8"><a href="#cb18-8" tabindex="-1"></a><span class="co">#&gt;    real double</span></span>
<span id="cb18-9"><a href="#cb18-9" tabindex="-1"></a><span class="co">#&gt;   &lt;dbl&gt;  &lt;dbl&gt;</span></span>
<span id="cb18-10"><a href="#cb18-10" tabindex="-1"></a><span class="co">#&gt; 1     1      1</span></span>
<span id="cb18-11"><a href="#cb18-11" tabindex="-1"></a><span class="co">#&gt; 2     2      2</span></span>
<span id="cb18-12"><a href="#cb18-12" tabindex="-1"></a><span class="co">#&gt; 3    NA     NA</span></span></code></pre></div>
<p>We can verify that both floating point types are translated to
<code>numeric</code>.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>purrr<span class="sc">::</span><span class="fu">map_chr</span>(df.floating_point, class)</span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a><span class="co">#&gt;      real    double </span></span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a><span class="co">#&gt; &quot;numeric&quot; &quot;numeric&quot;</span></span></code></pre></div>
</div>
<div id="fixed-precision-numbers" class="section level3">
<h3>Fixed-precision numbers</h3>
<p>Presto offers a <code>DECIMAL</code> data type that has fixed
precision up to 38 digits. This means that it can be used to represent a
very large integer which is obviously outside of the precision limits
mentioned above. We can’t decide one precise R class to translate the
<code>DECIMAL</code> data type into, so RPresto currently translates the
type into a string (i.e., <code>character</code>) in R.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a>(</span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a>  df.fixed_precision <span class="ot">&lt;-</span> <span class="fu">dbGetQuery</span>(</span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a>    con,</span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a>    <span class="st">&quot;SELECT decimal FROM presto_primitive_types&quot;</span></span>
<span id="cb20-5"><a href="#cb20-5" tabindex="-1"></a>  )</span>
<span id="cb20-6"><a href="#cb20-6" tabindex="-1"></a>)</span>
<span id="cb20-7"><a href="#cb20-7" tabindex="-1"></a><span class="co">#&gt; # A tibble: 3 × 1</span></span>
<span id="cb20-8"><a href="#cb20-8" tabindex="-1"></a><span class="co">#&gt;   decimal            </span></span>
<span id="cb20-9"><a href="#cb20-9" tabindex="-1"></a><span class="co">#&gt;   &lt;chr&gt;              </span></span>
<span id="cb20-10"><a href="#cb20-10" tabindex="-1"></a><span class="co">#&gt; 1 -9007199254740991.5</span></span>
<span id="cb20-11"><a href="#cb20-11" tabindex="-1"></a><span class="co">#&gt; 2 9007199254740991.5 </span></span>
<span id="cb20-12"><a href="#cb20-12" tabindex="-1"></a><span class="co">#&gt; 3 &lt;NA&gt;</span></span></code></pre></div>
</div>
<div id="strings" class="section level3">
<h3>Strings</h3>
<div id="varchar-and-char-types" class="section level4">
<h4><code>VARCHAR</code> and <code>CHAR</code> types</h4>
<p><a href="https://prestodb.io/docs/current/language/types.html#varchar"><code>VARCHAR</code></a>
and <a href="https://prestodb.io/docs/current/language/types.html#char"><code>CHAR</code></a>
data types in Presto are mapped to R’s <code>character</code> type.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>(</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>  df.characters <span class="ot">&lt;-</span> <span class="fu">dbGetQuery</span>(</span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a>    con,</span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a>    <span class="st">&quot;SELECT varchar, char FROM presto_primitive_types&quot;</span></span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a>  )</span>
<span id="cb21-6"><a href="#cb21-6" tabindex="-1"></a>)</span>
<span id="cb21-7"><a href="#cb21-7" tabindex="-1"></a><span class="co">#&gt; # A tibble: 3 × 2</span></span>
<span id="cb21-8"><a href="#cb21-8" tabindex="-1"></a><span class="co">#&gt;   varchar char </span></span>
<span id="cb21-9"><a href="#cb21-9" tabindex="-1"></a><span class="co">#&gt;   &lt;chr&gt;   &lt;chr&gt;</span></span>
<span id="cb21-10"><a href="#cb21-10" tabindex="-1"></a><span class="co">#&gt; 1 abc     a    </span></span>
<span id="cb21-11"><a href="#cb21-11" tabindex="-1"></a><span class="co">#&gt; 2 def     b    </span></span>
<span id="cb21-12"><a href="#cb21-12" tabindex="-1"></a><span class="co">#&gt; 3 &lt;NA&gt;    &lt;NA&gt;</span></span></code></pre></div>
<p>We can verify the resulting R types to be <code>character</code>.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a>purrr<span class="sc">::</span><span class="fu">map_chr</span>(df.characters, class)</span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a><span class="co">#&gt;     varchar        char </span></span>
<span id="cb22-3"><a href="#cb22-3" tabindex="-1"></a><span class="co">#&gt; &quot;character&quot; &quot;character&quot;</span></span></code></pre></div>
</div>
<div id="varbinary" class="section level4">
<h4><code>VARBINARY</code></h4>
<p>Presto’s <a href="https://prestodb.io/docs/current/language/types.html#varbinary"><code>VARBINARY</code></a>
type stores string data in raw bytes. It can be nicely mapped to R’s
<code>raw</code> type.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a>(</span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>  df.bytes <span class="ot">&lt;-</span> <span class="fu">dbGetQuery</span>(</span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a>    con,</span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a>    <span class="st">&quot;SELECT varbinary FROM presto_primitive_types&quot;</span></span>
<span id="cb23-5"><a href="#cb23-5" tabindex="-1"></a>  )</span>
<span id="cb23-6"><a href="#cb23-6" tabindex="-1"></a>)</span>
<span id="cb23-7"><a href="#cb23-7" tabindex="-1"></a><span class="co">#&gt; # A tibble: 3 × 1</span></span>
<span id="cb23-8"><a href="#cb23-8" tabindex="-1"></a><span class="co">#&gt;   varbinary</span></span>
<span id="cb23-9"><a href="#cb23-9" tabindex="-1"></a><span class="co">#&gt;   &lt;list&gt;   </span></span>
<span id="cb23-10"><a href="#cb23-10" tabindex="-1"></a><span class="co">#&gt; 1 &lt;raw [3]&gt;</span></span>
<span id="cb23-11"><a href="#cb23-11" tabindex="-1"></a><span class="co">#&gt; 2 &lt;raw [3]&gt;</span></span>
<span id="cb23-12"><a href="#cb23-12" tabindex="-1"></a><span class="co">#&gt; 3 &lt;raw [0]&gt;</span></span></code></pre></div>
<p>We can verify all elements in the resulting column are of
<code>raw</code> data type.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a>purrr<span class="sc">::</span><span class="fu">map_chr</span>(df.bytes<span class="sc">$</span>varbinary, class)</span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a><span class="co">#&gt; [1] &quot;raw&quot; &quot;raw&quot; &quot;raw&quot;</span></span></code></pre></div>
<p>We can also convert the bytes data back to the string values.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a>dplyr<span class="sc">::</span><span class="fu">mutate</span>(df.bytes, <span class="at">string =</span> purrr<span class="sc">::</span><span class="fu">map_chr</span>(varbinary, rawToChar))</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a><span class="co">#&gt; # A tibble: 3 × 2</span></span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a><span class="co">#&gt;   varbinary string</span></span>
<span id="cb25-4"><a href="#cb25-4" tabindex="-1"></a><span class="co">#&gt;   &lt;list&gt;    &lt;chr&gt; </span></span>
<span id="cb25-5"><a href="#cb25-5" tabindex="-1"></a><span class="co">#&gt; 1 &lt;raw [3]&gt; &quot;abc&quot; </span></span>
<span id="cb25-6"><a href="#cb25-6" tabindex="-1"></a><span class="co">#&gt; 2 &lt;raw [3]&gt; &quot;def&quot; </span></span>
<span id="cb25-7"><a href="#cb25-7" tabindex="-1"></a><span class="co">#&gt; 3 &lt;raw [0]&gt; &quot;&quot;</span></span></code></pre></div>
</div>
</div>
<div id="date-and-time" class="section level3">
<h3>Date and Time</h3>
<p>In R, there are three types of date/time data that refer to an
instant in time.</p>
<ul>
<li><p>A <strong>date</strong>. Tibbles print this as
<code>&lt;date&gt;</code>.</p></li>
<li><p>A <strong>time</strong> within a day. Tibbles print this as
<code>&lt;time&gt;</code>.</p></li>
<li><p>A <strong>date-time</strong> is a date plus a time: it uniquely
identifies an instant in time (typically to the nearest second). Tibbles
print this as <code>&lt;dttm&gt;</code>. Elsewhere in R these are called
<code>POSIXct</code>.</p></li>
</ul>
<p>We prefer to use the <code>lubridate</code> package to handle date
and date-time objects. Time objects are not very commonly used and R
lacks a strong native support for it. In <code>RPresto</code>, we uses
the <code>hms</code> package to handle time objects.</p>
<div id="date" class="section level4">
<h4><code>DATE</code></h4>
<p>The <a href="https://prestodb.io/docs/current/language/types.html#date"><code>DATE</code></a>
type is by far the most used date-and-time types. Note that a
<code>DATE</code> value isn’t tied to any particular time zone, so it
isn’t associated with a unique point in time (i.e., seconds or
microseconds since epoch).</p>
<p>We use base R’s <code>Date</code> S3 class to translate Presto’s
<code>DATE</code> type.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a>(</span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a>  df.date <span class="ot">&lt;-</span> <span class="fu">dbGetQuery</span>(</span>
<span id="cb26-3"><a href="#cb26-3" tabindex="-1"></a>    con,</span>
<span id="cb26-4"><a href="#cb26-4" tabindex="-1"></a>    <span class="st">&quot;SELECT date FROM presto_primitive_types&quot;</span></span>
<span id="cb26-5"><a href="#cb26-5" tabindex="-1"></a>  )</span>
<span id="cb26-6"><a href="#cb26-6" tabindex="-1"></a>)</span>
<span id="cb26-7"><a href="#cb26-7" tabindex="-1"></a><span class="co">#&gt; # A tibble: 3 × 1</span></span>
<span id="cb26-8"><a href="#cb26-8" tabindex="-1"></a><span class="co">#&gt;   date      </span></span>
<span id="cb26-9"><a href="#cb26-9" tabindex="-1"></a><span class="co">#&gt;   &lt;date&gt;    </span></span>
<span id="cb26-10"><a href="#cb26-10" tabindex="-1"></a><span class="co">#&gt; 1 2000-01-01</span></span>
<span id="cb26-11"><a href="#cb26-11" tabindex="-1"></a><span class="co">#&gt; 2 2000-01-02</span></span>
<span id="cb26-12"><a href="#cb26-12" tabindex="-1"></a><span class="co">#&gt; 3 NA</span></span></code></pre></div>
<p>We can verify the R type of the column.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a>purrr<span class="sc">::</span><span class="fu">map_chr</span>(df.date, class)</span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a><span class="co">#&gt;   date </span></span>
<span id="cb27-3"><a href="#cb27-3" tabindex="-1"></a><span class="co">#&gt; &quot;Date&quot;</span></span></code></pre></div>
</div>
<div id="timestamp" class="section level4">
<h4><code>TIMESTAMP</code></h4>
<p>The <code>POSIXct</code> type values, on the other hand, are
associated with a unique point in time. That is, they can be translated
to a unique numeric value that refers to the number of time units
(usually seconds, milliseconds, or microseconds) elapsed since epoch
(i.e., the beginning of time). This is why the mode of a
<code>POSIXct</code> value in R is numeric and you can call the
<code>as.integer()</code> function on it.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a>foo <span class="ot">&lt;-</span> lubridate<span class="sc">::</span><span class="fu">ymd_hms</span>(<span class="st">&quot;2000-01-01 01:02:03&quot;</span>, <span class="at">tz =</span> <span class="st">&quot;America/New_York&quot;</span>)</span>
<span id="cb28-2"><a href="#cb28-2" tabindex="-1"></a><span class="fu">mode</span>(foo)</span>
<span id="cb28-3"><a href="#cb28-3" tabindex="-1"></a><span class="co">#&gt; [1] &quot;numeric&quot;</span></span>
<span id="cb28-4"><a href="#cb28-4" tabindex="-1"></a><span class="fu">as.integer</span>(foo)</span>
<span id="cb28-5"><a href="#cb28-5" tabindex="-1"></a><span class="co">#&gt; [1] 946706523</span></span></code></pre></div>
<p>In this case, the integer value refers to the number of seconds
elapsed since 1970-01-01 00:00:00 in the UTC time zone.</p>
<p>Presto’s <a href="https://prestodb.io/docs/current/language/types.html#timestamp"><code>TIMESTAMP</code></a>
and <a href="https://prestodb.io/docs/current/language/types.html#timestamp-with-time-zone"><code>TIMESTAMP WITH TIME ZONE</code></a>
types follow the same logic and thus can be mapped to the
<code>POSIXct</code> type. To ensure consistency, <code>RPresto</code>
always translates the timestamp to match the Presto session’s
timezone.</p>
<p>You can check the session time zone by printing the
<code>session.timezone</code> slot of the <code>PrestoConnection</code>
object.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a>con<span class="sc">@</span>session.timezone</span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a><span class="co">#&gt; [1] &quot;UTC&quot;</span></span></code></pre></div>
<p>Here we get the <code>TIMESTAMP</code> and
<code>TIMESTAMP WITH TIME ZONE</code> values from the table.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a>(</span>
<span id="cb30-2"><a href="#cb30-2" tabindex="-1"></a>  df.posixct <span class="ot">&lt;-</span> <span class="fu">dbGetQuery</span>(</span>
<span id="cb30-3"><a href="#cb30-3" tabindex="-1"></a>    con,</span>
<span id="cb30-4"><a href="#cb30-4" tabindex="-1"></a>    <span class="st">&quot;SELECT timestamp, timestamp_with_tz FROM presto_primitive_types&quot;</span></span>
<span id="cb30-5"><a href="#cb30-5" tabindex="-1"></a>  )</span>
<span id="cb30-6"><a href="#cb30-6" tabindex="-1"></a>)</span>
<span id="cb30-7"><a href="#cb30-7" tabindex="-1"></a><span class="co">#&gt; # A tibble: 3 × 2</span></span>
<span id="cb30-8"><a href="#cb30-8" tabindex="-1"></a><span class="co">#&gt;   timestamp           timestamp_with_tz  </span></span>
<span id="cb30-9"><a href="#cb30-9" tabindex="-1"></a><span class="co">#&gt;   &lt;dttm&gt;              &lt;dttm&gt;             </span></span>
<span id="cb30-10"><a href="#cb30-10" tabindex="-1"></a><span class="co">#&gt; 1 2000-01-01 01:02:03 2000-01-01 06:02:03</span></span>
<span id="cb30-11"><a href="#cb30-11" tabindex="-1"></a><span class="co">#&gt; 2 2000-01-02 02:03:04 2000-01-02 07:03:04</span></span>
<span id="cb30-12"><a href="#cb30-12" tabindex="-1"></a><span class="co">#&gt; 3 NA                  NA</span></span></code></pre></div>
<p>We can check the R types of the two columns.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a>purrr<span class="sc">::</span><span class="fu">map</span>(df.posixct, class)</span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a><span class="co">#&gt; $timestamp</span></span>
<span id="cb31-3"><a href="#cb31-3" tabindex="-1"></a><span class="co">#&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot; </span></span>
<span id="cb31-4"><a href="#cb31-4" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb31-5"><a href="#cb31-5" tabindex="-1"></a><span class="co">#&gt; $timestamp_with_tz</span></span>
<span id="cb31-6"><a href="#cb31-6" tabindex="-1"></a><span class="co">#&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot;</span></span></code></pre></div>
<p>We can also verify that the time zone attributes match the session
time zone.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a>purrr<span class="sc">::</span><span class="fu">map_chr</span>(df.posixct<span class="sc">$</span>timestamp, lubridate<span class="sc">::</span>tz)</span>
<span id="cb32-2"><a href="#cb32-2" tabindex="-1"></a><span class="co">#&gt; [1] &quot;UTC&quot; &quot;UTC&quot; &quot;UTC&quot;</span></span>
<span id="cb32-3"><a href="#cb32-3" tabindex="-1"></a>purrr<span class="sc">::</span><span class="fu">map_chr</span>(df.posixct<span class="sc">$</span>timestamp_with_tz, lubridate<span class="sc">::</span>tz)</span>
<span id="cb32-4"><a href="#cb32-4" tabindex="-1"></a><span class="co">#&gt; [1] &quot;UTC&quot; &quot;UTC&quot; &quot;UTC&quot;</span></span></code></pre></div>
</div>
<div id="intervals" class="section level4">
<h4><code>INTERVAL</code>s</h4>
<p>Presto has two <code>INTERVAL</code> types: <a href="https://prestodb.io/docs/current/language/types.html#interval-year-to-month"><code>INTERVAL YEAR TO MONTH</code></a>
and <a href="https://prestodb.io/docs/current/language/types.html#interval-day-to-second"><code>INTERVAL DAY TO SECOND</code></a>.
We map both of them to <code>lubridate::Duration-class</code>.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a>(</span>
<span id="cb33-2"><a href="#cb33-2" tabindex="-1"></a>  df.duration <span class="ot">&lt;-</span> <span class="fu">dbGetQuery</span>(</span>
<span id="cb33-3"><a href="#cb33-3" tabindex="-1"></a>    con,</span>
<span id="cb33-4"><a href="#cb33-4" tabindex="-1"></a>    <span class="st">&quot;</span></span>
<span id="cb33-5"><a href="#cb33-5" tabindex="-1"></a><span class="st">    SELECT</span></span>
<span id="cb33-6"><a href="#cb33-6" tabindex="-1"></a><span class="st">      interval_year_to_month,</span></span>
<span id="cb33-7"><a href="#cb33-7" tabindex="-1"></a><span class="st">      interval_day_to_second</span></span>
<span id="cb33-8"><a href="#cb33-8" tabindex="-1"></a><span class="st">    FROM presto_primitive_types</span></span>
<span id="cb33-9"><a href="#cb33-9" tabindex="-1"></a><span class="st">    &quot;</span></span>
<span id="cb33-10"><a href="#cb33-10" tabindex="-1"></a>  )</span>
<span id="cb33-11"><a href="#cb33-11" tabindex="-1"></a>)</span>
<span id="cb33-12"><a href="#cb33-12" tabindex="-1"></a><span class="co">#&gt; # A tibble: 3 × 2</span></span>
<span id="cb33-13"><a href="#cb33-13" tabindex="-1"></a><span class="co">#&gt;   interval_year_to_month  interval_day_to_second</span></span>
<span id="cb33-14"><a href="#cb33-14" tabindex="-1"></a><span class="co">#&gt;   &lt;Duration&gt;              &lt;Duration&gt;            </span></span>
<span id="cb33-15"><a href="#cb33-15" tabindex="-1"></a><span class="co">#&gt; 1 36817200s (~1.17 years) 187506.5s (~2.17 days)</span></span>
<span id="cb33-16"><a href="#cb33-16" tabindex="-1"></a><span class="co">#&gt; 2 73634400s (~2.33 years) 284889.6s (~3.3 days) </span></span>
<span id="cb33-17"><a href="#cb33-17" tabindex="-1"></a><span class="co">#&gt; 3 NA                      NA</span></span></code></pre></div>
</div>
</div>
</div>
<div id="walkthrough-wrap-up" class="section level2">
<h2>Walkthrough wrap-up</h2>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a>DBI<span class="sc">::</span><span class="fu">dbDisconnect</span>(con)</span>
<span id="cb34-2"><a href="#cb34-2" tabindex="-1"></a><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
